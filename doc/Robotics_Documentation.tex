\documentclass[a4paper,12pt]{article}

\usepackage[margin=0.8in]{geometry} % Sets a 0.8 inch margin on all four sides 
\usepackage{parskip} % Block Paragraphs
\usepackage{fancyhdr} % Fancy headers and footers
\usepackage{graphicx} % Enables images
\usepackage{pdfpages} % Embedded PDF files
\usepackage{caption} % Enables captions
\usepackage{mdframed} % Enables frames
\usepackage{verbatim} % Enables insertion of text files
\usepackage{wrapfig} % Wrapped figures
\usepackage{algorithm2e} % Algorithms
\usepackage{tikz} % Drawing
\usepackage{verbatim} % Embed text files
\usepackage[colorlinks=true,urlcolor=blue,linkcolor=blue,linktocpage=true]{hyperref} % Hypertext referencing

\usetikzlibrary{decorations.pathmorphing,calc,shadows.blur,shadings}
\pgfmathsetseed{1} % To have predictable results
% Define a background layer, in which the parchment shape is drawn
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

% This is the base for the fractal decoration. It takes a random point between the start and end, and
% raises it a random amount, thus transforming a segment into two, connected at that raised point
% This decoration can be applied again to each one of the resulting segments and so on, in a similar
% way of a Koch snowflake.
\pgfdeclaredecoration{irregular fractal line}{init}
{
  \state{init}[width=\pgfdecoratedinputsegmentremainingdistance]
  {
    \pgfpathlineto{\pgfpoint{random*\pgfdecoratedinputsegmentremainingdistance}{(random*\pgfdecorationsegmentamplitude-0.02)*\pgfdecoratedinputsegmentremainingdistance}}
    \pgfpathlineto{\pgfpoint{\pgfdecoratedinputsegmentremainingdistance}{0pt}}
  }
}

% define some styles
\tikzset{
   paper/.style={draw=black!10, blur shadow, shade=bilinear interpolation,
                 lower left=black!20, upper left=black!15, upper right=white, lower right=black!10},
   irregular border/.style={decoration={irregular fractal line, amplitude=0.2},
           decorate,
     },
   ragged border/.style={ decoration={random steps, segment length=7mm, amplitude=2mm},
           decorate,
   }
}

% Macro to draw the shape behind the text, when it fits completly in the
% page
\def\tornpaper#1{
\tikz{
  \node[inner sep=1em] (A) {#1};  % Draw the text of the node
  \begin{pgfonlayer}{background}  % Draw the shape behind
  \fill[paper] % recursively decorate the bottom border
        decorate[irregular border]{decorate{decorate{decorate{decorate[ragged border]{
        ($(A.south east) - (0, random*5mm)$) -- ($(A.south west) - (0, random*5mm)$)
        }}}}}
        -- (A.north west) -- (A.north east) -- cycle;
  \end{pgfonlayer}}
}

\usepackage{enumitem}
\newlist{arrowlist}{itemize}{1}
\setlist[arrowlist]{label=$\Rightarrow$} % Use command \begin {arrowlist} rather than \begin{itemize} for arrows

\usepackage{color} % Enables colours
\definecolor{darkpurple}{rgb}{0.4, 0.0, 0.4} % Defines a dark purple colour
\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\pagestyle{fancy} % Set new page style
\frenchspacing % One space after a full stop
\parindent=0in % Do not indent paragraphs
\brokenpenalty10000\relax % Do not page break at a hyphen

\fancyhf{} % clear all header and footers
\renewcommand{\headrulewidth}{0pt} % remove the header rule
\rfoot{\thepage} 

\usepackage{listings}
  \usepackage{courier}
  \lstloadlanguages{C++}
  \lstset{
         language=C++,
         basicstyle=\footnotesize\ttfamily, 
         numbers=left,               
         numberstyle=\tiny,          
         numbersep=10pt,              
         tabsize=4,                  
         extendedchars=true,         
         breaklines=true,            
    	 frame=lrtb,         
         keywordstyle=\color{javapurple}\bfseries,
         stringstyle=\color{javared},
         commentstyle=\color{javagreen},
         morecomment=[s][\color{javadocblue}]{/**}{*/},
         showspaces=false,           
         showtabs=false,            
         xleftmargin=17pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         %backgroundcolor=\color{},
         showstringspaces=false      
 }

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

\begin{document}

\includepdf{title/assign_cover.pdf} % Coversheet
\includepdf{title/title_page.pdf} % Include title page

\thispagestyle{empty} % Clear page style
\tableofcontents % TOC
\clearpage
\pagenumbering{arabic} % Resets numbering

\section{Introduction}
The purpose of this assignment was to implement a simulated robot to navigate an occupancy grid and then to investigate the differences when this program was used on a real \textit{Pioneer} robot. This involved several aspects including navigation, pathfinding, precision movement, navigation and representation of the (simulated or real) environment using appropriate data structures. 

My implementation focused on the following aspects:

\begin{arrowlist}
    \item{Navigating a simulated grid}
    \item{Searching for an efficient path using stored data as a reference}
    \item{Planning and navigating a given route}
    \item{Versatility in start positions, the robot will recalculate its path regularly}
    \item{Environmental awareness of obstacles, including disallowing illegal goal positions}
\end{arrowlist}

In addition to this, this program was tested on a real robot and results observed. The pathfinding implementation is deliberative as opposed to reactive - my justification for this is that sonars are unnecessary when a full map of the environment has already been achieved. I familiarised myself with both approaches during the design phase.

Throughout the project, source control was used - both for backup purposes and to provide a record of progress made during the development of my solution.

\scriptsize
\noindent
\tornpaper{
    \parbox{\textwidth}{\verbatiminput{../../Misc/Commit_History.txt}}
}
\normalsize

\section{Player/Stage}
\textit{Player/Stage} is a robotics simulation platform - it combines a simulator (\textit{Stage}) with a client \textit{Player} for use with programming robots. \textit{Player/Stage} makes use of a TCP based architecture \cite{pstcp} and is therefore network aware. With minor changes, the same code used in the simulator can be executed on a real robot.

\textit{Player/Stage} proved difficult to install even on the recommended platform (32-bit Linux) and was prone to crashes and graphical glitches (e.g. grid axis disappearing). I installed it from source on Mac OS X and it was similarly unreliable. Additionally, there was not much documentation provided and the Java API seemed to have a number of bugs. 

For this reason, as well as personal preference, C++ was used to implement my navigation system.
\section{Representation}
The first step to solving the issue of navigating the grid was to determine how best to represent states within the program. I decided to use a \texttt{grid} class to represent the occupancy grid and there was also a need for a node class to store potential states for use in a graph search. 
\subsection{Grid Class}
The \textbf{Grid} class provides key functionality. It stores the occupancy grid and provides several auxiliary functions to detect obstacles as well as the critically important \texttt{mapToGridArray} function which converts between $x,y$ coordinates and indices in a two-dimensional \textit{vector} of type \textit{int} values. 

This function is crucial and is used throughout the program whenever a conversion is needed between apparent position on the screen and the internal grid. This will be discussed in more detail in a later section.
\subsection{Node Class}
The \textbf{Node} class provides all the required functionality to describe a state during navigation. The following table describes the attributes stored in a node object.
\begin{table}
\centering
\scriptsize
\begin{tabular}{|c|c|l|}
    \hline
    \multicolumn{1}{|c|}{\textbf{Attribute}} & \multicolumn{1}{c|}{\textbf{Type}} & \multicolumn{1}{c|}{\textbf{Purpose}} \\
    \hline
    nodeCount & \texttt{static int} & Class-side variable that is updated in the constructor with every new \texttt{Node} instance\\
    \hline
    nodeId & \texttt{int} & Uniquely identifies a Node, increments \texttt{nodeCount} in every new instance\\
    \hline
    parentNode & \texttt{Node*} & Pointer to the parent node, allows tree traversal from leaf to root node \\
    \hline
    gridState & \texttt{Grid} & Instance of a \texttt{Grid},  the current grid state in its entirety\\
    \hline
    pathCost & \texttt{int} & Current path cost, for positions not adjacent to obstacles this will be \texttt{parentNode->getPathCost() + 1} \\
    \hline
    xPos & \texttt{int} & Current \textbf{x} coordinate of robot on grid, one part of uniquely identifying a \texttt{Node} \\
    \hline
    yPos & \texttt{int} & Current \textbf{y} coordinate of robot on grid, second part of unique identifier\\
    \hline
    moveDir & \texttt{Direction} & Instance of the \texttt{Direction} enumerated value - see section on movement\\
    \hline
\end{tabular}
\end{table}
\normalsize
Nodes are created and stored as required, once the path from the start to the goal has been found, The path is reversed and 'replayed' by giving movement commands to the robot sequentially.
\subsection{Occupancy Grid Mapping}
One of the crucial functions required for any movement was the ability to map the robot's apparent position in the simulator to an index in the internal vector. After some experimentation the equation for the position was discovered and the algorithm was implemented. 

Below you can see the basic algorithm, example output to check for correctness and my C\texttt{++} implementation which returns a \texttt{<std::pair>}.

\begin{mdframed}
    \begin{minipage}[t]{.5\textwidth}
            \vspace{0.2cm}
        \small
        \begin{algorithm}[H]
            \DontPrintSemicolon
            \SetAlgoLined
            \KwData{Grid Coordinates of form x,y}
            \KwResult{Indices for position in 2D \textit{vector}}
                \hspace{0.6cm}Let gridX = input x coordinate\\
                \hspace{0.5cm} Let gridY = input y coordinate\\
                \vspace{0.3cm}
                \hspace{0.5cm} Let indexX := $10\:+$ gridX\\
                \hspace{0.5cm} Let indexY := $9\:-$ gridY\\
                \vspace{0.3cm}
                \hspace{0.6cm}\Return indexX, indexY\;
        \end{algorithm}
        \normalsize
    \end{minipage}
    \begin{minipage}[t]{.5\textwidth}
            \small
            \vspace{0.2cm}
            \verbatiminput{/dev/shm/foo.txt}
            \normalsize
    \end{minipage}
\end{mdframed}

\lstset{caption={Mapping Function}}
\begin{lstlisting}
std::pair<int,int> Grid::mapToGridArray(int xPos, int yPos)
{
    std::pair<int,int> arrayPosition;

    arrayPosition.first = 9 - yPos ; // The row
    arrayPosition.second = 10 + xPos; // The column

    /* Returns the 2D vector indices of the given x,y coordinate */
    return arrayPosition; 
}
\end{lstlisting}
% picture here?
\subsection{Movement}
% update index on robot move to keep current 
% discuss booleans
\section{Navigation and Localisation}
% pp.GetX() 
\section{Reactive and Deliberative Pathfinding}
Robots can be broadly classified into three categories:

\begin{arrowlist}
    \item{Reactive}
    \item{Deliberative}
    \item{Hybrid}
\end{arrowlist}
When designing this software it was important to consider the advantages and disadvantages of these approaches. 

Reactive robotics is based on a direct mapping between sensors and output and focuses on being fast and uncomplicated. This approach may provide similar results in the simulator as it does on the real robot because it does not require an internal representation of the environment, it reacts to obstacles as they appear.

The way to perform this sort of reactive pathing on the \textit{Pioneer} is through the use of sonars.

Deliberative robotics uses planning and constructs an internal representation of the environment which can be manipulated internally before the robot moves. The typical way a deliberative pathfinder works would be to look ahead using AI search techniques (commonly \textit{A*} or \textit{Best First} Search) and calculate the route needed to get from the start position to the goal position without colliding with any obstacles.

This approach is ideal when obstacles are static and the movement is not time-critical, allowing time for calculating an ideal route. As obstacles on the provided occupancy grid do not move, this navigation method could prove very effective. There is also potential for the search to be more dynamic by recalculating the path should the robot be moved or come near obstacles.

Representation could prove troublesome because the robot will have to represent positions, obstacles and so forth as abstractions. This is in contrast to the reactive approach which uses the "world as its own best model" approach. Another potential difficulty is the need to keep the internal model synchronised with the robots movements in the simulated or real environment.

Hybrid robotics would involve a combination of both navigational techniques. This would appear to be ideal and would involve constructing a map using sonar data as a dynamic input.
\subsection{Sonar}
\begin{wrapfigure}{r}{0.5\textwidth}
    \begin{center}
            \includegraphics[width=0.47\textwidth]{images/sonars_wiki_dcs_aber_ac_uk.png}
            \caption{Layout of sonars on the \textit{Pioneer} \cite{sonardiagram}}
            \end{center}
        \end{wrapfigure}

The \textit{Pioneer} robot has an array of between eight and sixteen sonars which allow for obstacle detection.

These are potentially more effective in the simulator as they are not at risk of cross-talk or environmental factors. 

If two sonar equipped robots are near each other then their sonar readings could be responding to the sonar outputs from the other robots and cause issues.

It is also possible that sonars in a simulated environment will prove more effective than those in a real environment.

Sonars are easy to use in the provided C++ API via a \texttt{RangerProxy} or \texttt{SonarProxy} for simulation or real environments respectively. 

Sonars are indexed from $0-15$ and can be accessed using standard array notation.

\lstset{caption={Example Sonar Handling}, mathescape=true}
\begin{lstlisting}
if (rp[3] < 1 || rp[4] < 1) // An object is detected in front of the robot
{
    pp.SetSpeed(-0.700, dtor(60)); // Move backwards whilst turning $60^\circ$
    usleep(300000); // Hold movement for 3 seconds
} 
\end{lstlisting}
\subsection{Graph Search}
% A* algorithm, path cost - adjacency checks, travelling back up the nodes, 'replaying' correct commands
\section{Development}
% basic intro
\subsection{Early Ideas}
Early on in the development process I looked at using a very crude reactive approach by simply having the robot check sonars and randomly move about the environment. This was effective but did not involve any intelligent motion or significant robotics knowledge. 

I discovered that the \textit{Player/Stage} API provided a \texttt{GoTo} function as a member of the \texttt{PositionProxy} class. This function would allow me to input a position using the \texttt{player2d\_pose\_t} type (a simple pair like structure) and from there the robot would navigate to this position on the grid.

This seemed like a very simple solution - avoid obstacles with the sonar and move towards the goal position. After running some tests I concluded that the \texttt{GoTo} function was not intelligent and would simply move to the position in a straight line. I also discovered that commands sent to the robot are executed until a new command is received.

What this meant was that I would have to repeatedly send \texttt{GoTo} commands and pause for the sonar data to be read, very inelegant. Because there was no intelligence the robot would often come too close to obstacles and get stuck when trying to turn or become caught in a loop where it moved towards an obstacle, backed away and moved towards it again.

It was clear I would need to try a different approach. I I discovered that the \texttt{usleep} function provided in \textit{cstdlib} would allow commands sent to the robot to be carried out for a length of time before the new command was sent - this seemed useful but did not prevent issues where a robot would move towards an obstacle, and be asleep while the sonar should have been picking up new data and sending an avoidance command.

This could have been fixed by implementing some sort of threading capability or using an interrupt but it seemed less about robotics and more about C\texttt{++} features so I decided on a different perspective.

I began by attempting to implement a simple Breadth-First Search which required the creation of a Node class. I moved everything around in memory without sending commands to the robot yet in order to see if this was feasible. It worked quite well and I decided to continue with the deliberative approach, however the breadth-first search proved extremely slow when moving away from the robot
% fully reactive, looking into GoTo - issues, discovered usleep() - BFS
\subsection{Final Implementation}
% BFS became Be-Fi-Se became A* when realised that needed path cost to stop it 'hugging' obstacles - had to implement path cost, then had to add checks for both diagonal and etc in isAdjacentToObstacle() because otherwise would just hit things. Also had to make isGoal slightly less precise because otherwise it would travel to the very edge of a grid cell and hit obstacles. 
\section{Testing}
% few screenshots here 
\section{Real Robots}
% ignored goto, picture of pioneer here
\section{Conclusions}
% sim nowhere near like real life, importance of sleep statements
Overall this project proved quite challenging because applying AI techniques to the environment is not as 'clean' as it is when dealing with a structure that exists only in memory.

\subsection{Software Evaluation} % Slightly buggy, more testing, sometimes stops before goal state - if input == currentPos then crash
There are a few bugs in my implementation but nothing which detracts from the ability to navigate the occupancy grid successfully. Occasionally the robot will stop just short of the goal with a \texttt{PlayrCc::PlayerError} - I have not ascertained whether this is a bug with my software or something else.

Additionally, as soon as the \texttt{PositionProxy} object is instantiated, the \textbf{simulated} robot will begin to move. In order to make it wait for input. I don't instantiate it until after the user has input the goal coordinates. 

This causes a crash if the goal coordinates equal the start coordinates with no way of checking because \texttt{getXPos()} and so forth are not available yet. 

To fix this I could have the robot move in circles, however the real robot does not exhibit this problem due to \texttt{setMotorEnable(false)} being called.
\section{References}

%[1] \textit{} [Online]. Available:\\ 
%    \url{}

\end{document}

